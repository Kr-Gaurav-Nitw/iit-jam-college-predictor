# -*- coding: utf-8 -*-
"""project_ui_app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ghsNH9ylYf1XDMsPGhOdZQN_n3DwuBtu
"""

# project_ui_app.py
import streamlit as st
import pandas as pd
import numpy as np

# ---------------------------
# Page config
# ---------------------------
st.set_page_config(page_title="IIT JAM College Predictor", page_icon="üéì", layout="centered")

# ---------------------------
# Load Data
# ---------------------------
@st.cache_data
def load_data():
    df = pd.read_csv("data_2020_2025.csv")
    df.columns = df.columns.str.strip()

    # Ensure Program column
    if "Program" not in df.columns and "Course Name" in df.columns:
        df["Program"] = df["Course Name"]

    # Ensure Opening/Closing columns
    if "Opening Rank" not in df.columns and "Opening" in df.columns:
        df["Opening Rank"] = df["Opening"]
    if "Closing Rank" not in df.columns and "Closing" in df.columns:
        df["Closing Rank"] = df["Closing"]

    # Compute historical averages
    group_cols = ["Institute", "Program", "Category"]
    range_stats = (
        df.groupby(group_cols)
        .agg(Open_Mean=("Opening Rank", "mean"), Close_Mean=("Closing Rank", "mean"))
        .reset_index()
    )
    return df, range_stats

df, range_stats = load_data()

# ---------------------------
# Helper: assess chance
# ---------------------------
def assess_rank_range_mean(rank, inst, program, category, buffer=50):
    row = range_stats[
        (range_stats["Institute"].str.upper() == inst.upper()) &
        (range_stats["Program"].str.upper() == program.upper()) &
        (range_stats["Category"].str.upper() == category.upper())
    ]
    if row.empty:
        return None, None, None
    o = int(row["Open_Mean"].values[0])
    c = int(row["Close_Mean"].values[0])
    if rank <= o:
        tag = f"üéØ Sure Shot (better than past Opening {o})"
    elif o < rank <= c:
        tag = f"‚úÖ Likely (within past range {o}-{c})"
    elif c < rank <= c + buffer:
        tag = f"‚ö†Ô∏è Borderline (within +{buffer} of Closing {c})"
    else:
        tag = f"‚ùå Unlikely (past cutoff {c})"
    return tag, o, c

# ---------------------------
# UI
# ---------------------------
st.title("üéì JAM College Predictor")
st.markdown("Predict your IIT ")

col1, col2 = st.columns([2, 3])
with col1:
    # year = st.selectbox("Exam Year (optional)", sorted(df["Year"].unique()), index=0)
    rank = st.number_input("Enter your Rank", min_value=1, step=1, value=200)
    category = st.selectbox("Category", sorted(df["Category"].unique()))
with col2:
    unique_programs = sorted(df["Program"].dropna().unique())
    program = st.selectbox("Program", unique_programs)

predict_btn = st.button("üîÆ Predict")

# ---------------------------
# Run Prediction
# ---------------------------
# ---------------------------
# Run Prediction
# ---------------------------
# ---------------------------
# Run Prediction
# ---------------------------
if predict_btn:
    candidate_insts = df[
        (df["Program"].str.upper() == program.upper()) &
        (df["Category"].str.upper() == category.upper())
    ]

    if candidate_insts.empty:
        st.warning("‚ùå No historical records for this Program + Category combination.")
    else:
        # üîπ Compute maximum historical cutoff
        max_cutoff = candidate_insts["Closing Rank"].max()

        if rank > max_cutoff:
            st.error(
                f"‚ùå With Rank {rank} in '{category}' for '{program}', "
                f"no IIT seats were historically available (max cutoff: {max_cutoff})."
            )
        else:
            rows = []
            for inst in candidate_insts["Institute"].unique():
                tag, o, c = assess_rank_range_mean(rank, inst, program, category)
                if tag is None:
                    continue
                diff = abs(rank - c)
                rows.append((inst, o, c, diff, tag))

            if not rows:
                st.warning("‚ùå No IITs found within historical cutoff limits.")
            else:
                # üîπ Sort by Open_Mean (smaller = higher preference), then by diff
                rows_sorted = sorted(rows, key=lambda x: (x[1], x[3]))

                out = pd.DataFrame(
                    rows_sorted, columns=["Institute", "Open_Mean", "Close_Mean", "Diff", "Assessment"]
                )

                st.subheader("üèõÔ∏è Historical Cutoff Analysis (Available IITs)")
                st.table(out[["Institute", "Open_Mean", "Close_Mean", "Assessment"]])